"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addXmlElement = exports.addXmlNode = exports.newXmlNode = exports.findXmlMatching = exports.findXmlNodeContent = exports.findXmlNode = exports.findXmlNodes = exports.readXml = exports.XmlBuilder = void 0;
const xmlbuilder2_1 = require("xmlbuilder2");
const xpath_1 = require("xpath");
class XmlBuilder {
    constructor(xmlBuilder) {
        this.xmlBuilder = xmlBuilder;
    }
    addNode(node, content, attributes) {
        let result = this.xmlBuilder.ele(node, attributes);
        if (content) {
            result = result.txt(content);
        }
        return result;
    }
    build() {
        return this.xmlBuilder;
    }
}
exports.XmlBuilder = XmlBuilder;
function readXml(xmlContent, ignoreNamespace = true) {
    return xmlbuilder2_1.create(ignoreNamespace ? {
        defaultNamespace: {
            ele: null,
            att: null
        }
    } : {}, xmlContent);
}
exports.readXml = readXml;
function findXmlNodes(xml, xpath, ignoreNamespace = true) {
    let realXpath = xpath;
    if (ignoreNamespace) {
        const prefix = xpath.startsWith('//') ? '//' : '/';
        realXpath = prefix + xpath.split('/')
            .filter(p => p.length > 0)
            .map(p => p.trim().replace(/^(\w+)(?:\[[^]+\])?$/, `*[local-name() = '$1']`))
            .join('/');
    }
    return xpath_1.select(realXpath, asXmlNode(xml));
}
exports.findXmlNodes = findXmlNodes;
function findXmlNode(xml, xpath, ignoreNamespace = true) {
    var _a;
    return (_a = findXmlNodes(xml, xpath, ignoreNamespace)) === null || _a === void 0 ? void 0 : _a[0];
}
exports.findXmlNode = findXmlNode;
function findXmlNodeContent(xml, xpath, ignoreNamespace = true) {
    const node = findXmlNode(xml, xpath, ignoreNamespace);
    if (isNode(node)) {
        return node.textContent;
    }
    return node === null || node === void 0 ? void 0 : node.toString();
}
exports.findXmlNodeContent = findXmlNodeContent;
function findXmlMatching(xml, xpath, ignoreNamespace = true) {
    const node = findXmlNode(xml, xpath, ignoreNamespace);
    if (node) {
        return xmlbuilder2_1.builder(ignoreNamespace ? {
            defaultNamespace: {
                ele: null,
                att: null
            }
        } : {}, node);
    }
    return null;
}
exports.findXmlMatching = findXmlMatching;
function newXmlNode(content) {
    return xmlbuilder2_1.create(content);
}
exports.newXmlNode = newXmlNode;
function addXmlNode(target, node) {
    return target.import(newXmlNode(node));
}
exports.addXmlNode = addXmlNode;
function addXmlElement(target, ...elements) {
    let result = target;
    elements.forEach(elm => {
        result = (typeof elm === 'string') ? result.ele(elm) : result.ele(elm.name, elm.attributes);
    });
    return result;
}
exports.addXmlElement = addXmlElement;
function asXmlNode(xml) {
    return xml.node;
}
function isNode(value) {
    var _a;
    return ((_a = value) === null || _a === void 0 ? void 0 : _a.nodeType) !== undefined;
}
//# sourceMappingURL=xml-utils.js.map